{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///home/nova/apps/tracking/src/lib/mongodb.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nif (!MONGODB_URI) {\n  throw new Error('Please define the MONGODB_URI environment variable inside .env.local');\n}\n\nlet cached = (global as { mongoose?: { conn: null | typeof mongoose; promise: null | Promise<typeof mongoose> } }).mongoose;\n\nif (!cached) {\n  cached = (global as { mongoose?: { conn: null | typeof mongoose; promise: null | Promise<typeof mongoose> } }).mongoose = { conn: null, promise: null };\n}\n\nasync function connectDB() {\n  // If already connected, return cached connection\n  if (cached?.conn) {\n    console.log('🔄 Using cached MongoDB connection');\n    return cached.conn;\n  }\n\n  // If no promise exists, create one\n  if (!cached?.promise) {\n    console.log('🔌 Connecting to MongoDB...');\n    console.log('🌍 Environment:', process.env.NODE_ENV);\n    console.log('🔗 MongoDB URI:', MONGODB_URI?.replace(/\\/\\/.*@/, '//***:***@')); // Hide credentials in logs\n    \n    const opts = {\n      bufferCommands: false,\n      maxPoolSize: 10,\n      serverSelectionTimeoutMS: 5000,\n      socketTimeoutMS: 45000,\n    };\n\n    if (cached) {\n      cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\n        console.log('✅ MongoDB connected successfully');\n        console.log('📊 Database name:', mongoose.connection.name);\n        return mongoose;\n      });\n    }\n  }\n\n  try {\n    if (cached) {\n      cached.conn = await cached.promise;\n    }\n  } catch (e) {\n    console.error('❌ MongoDB connection failed:', e);\n    if (cached) {\n      cached.promise = null;\n    }\n    throw e;\n  }\n\n  return cached?.conn;\n}\n\n// Handle connection events\nmongoose.connection.on('connected', () => {\n  console.log('🟢 Mongoose connected to MongoDB');\n});\n\nmongoose.connection.on('error', (err) => {\n  console.error('🔴 Mongoose connection error:', err);\n});\n\nmongoose.connection.on('disconnected', () => {\n  console.log('🟡 Mongoose disconnected from MongoDB');\n});\n\nexport default connectDB;"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAEA,IAAI,SAAS,4CAAsG,QAAQ;AAE3H,IAAI,CAAC,QAAQ;IACX,SAAS,4CAAsG,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AACxJ;AAEA,eAAe;IACb,iDAAiD;IACjD,IAAI,QAAQ,MAAM;QAChB,QAAQ,GAAG,CAAC;QACZ,OAAO,OAAO,IAAI;IACpB;IAEA,mCAAmC;IACnC,IAAI,CAAC,QAAQ,SAAS;QACpB,QAAQ,GAAG,CAAC;QACZ,QAAQ,GAAG,CAAC;QACZ,QAAQ,GAAG,CAAC,mBAAmB,aAAa,QAAQ,WAAW,gBAAgB,2BAA2B;QAE1G,MAAM,OAAO;YACX,gBAAgB;YAChB,aAAa;YACb,0BAA0B;YAC1B,iBAAiB;QACnB;QAEA,IAAI,QAAQ;YACV,OAAO,OAAO,GAAG,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;gBAC1D,QAAQ,GAAG,CAAC;gBACZ,QAAQ,GAAG,CAAC,qBAAqB,SAAS,UAAU,CAAC,IAAI;gBACzD,OAAO;YACT;QACF;IACF;IAEA,IAAI;QACF,IAAI,QAAQ;YACV,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;QACpC;IACF,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,IAAI,QAAQ;YACV,OAAO,OAAO,GAAG;QACnB;QACA,MAAM;IACR;IAEA,OAAO,QAAQ;AACjB;AAEA,2BAA2B;AAC3B,yGAAA,CAAA,UAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,aAAa;IAClC,QAAQ,GAAG,CAAC;AACd;AAEA,yGAAA,CAAA,UAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,CAAC;IAC/B,QAAQ,KAAK,CAAC,iCAAiC;AACjD;AAEA,yGAAA,CAAA,UAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,gBAAgB;IACrC,QAAQ,GAAG,CAAC;AACd;uCAEe","debugId":null}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"sources":["file:///home/nova/apps/tracking/src/lib/stream-utils.ts"],"sourcesContent":["import connectDB from './mongodb';\n\n// Array to store active SSE connections\nlet clients: Array<{ id: string; controller: ReadableStreamDefaultController }> = [];\n\n// Function to send updates to a specific client\nasync function sendUpdate(controller: ReadableStreamDefaultController) {\n  try {\n    await connectDB();\n    \n    const Contract = (await import('../models/Contract')).default;\n    const contracts = await Contract.find().sort({ createdAt: -1 });\n    \n    const transformedContracts = contracts.map(contract => ({\n      id: contract._id.toString(),\n      phone_number: contract.phone_number,\n      lot_number: contract.lot_number,\n      equipment_number: contract.equipment_number,\n      equipment_type: contract.equipment_type,\n      freight_rate: contract.freight_rate,\n      type_of_service: contract.type_of_service,\n      total_value: contract.total_value,\n      contract_status: contract.contract_status,\n      date: contract.date,\n      truck_driver: contract.truck_driver,\n      createdAt: contract.createdAt,\n      updatedAt: contract.updatedAt,\n      signatureData: contract.signatureData\n    }));\n\n    controller.enqueue(`data: ${JSON.stringify({ type: 'contracts', data: transformedContracts })}\\n\\n`);\n  } catch (error) {\n    console.error('Error sending update:', error);\n  }\n}\n\n// Function to notify all clients of new data\nexport function notifyClients() {\n  clients.forEach(client => {\n    try {\n      sendUpdate(client.controller);\n    } catch {\n      // Remove failed client\n      clients = clients.filter(c => c.id !== client.id);\n    }\n  });\n}\n\n// Function to notify all clients of a new contract\nexport function notifyNewContract() {\n  clients.forEach(client => {\n    try {\n      client.controller.enqueue(`data: ${JSON.stringify({ type: 'new_contract' })}\\n\\n`);\n    } catch {\n      // Remove failed client\n      clients = clients.filter(c => c.id !== client.id);\n    }\n  });\n}\n\n// Function to add a client to the list\nexport function addClient(client: { id: string; controller: ReadableStreamDefaultController }) {\n  clients.push(client);\n}\n\n// Function to remove a client from the list\nexport function removeClient(clientId: string) {\n  clients = clients.filter(client => client.id !== clientId);\n}\n\n// Function to get sendUpdate for the route\nexport { sendUpdate };"],"names":[],"mappings":";;;;;;;AAAA;;AAEA,wCAAwC;AACxC,IAAI,UAA8E,EAAE;AAEpF,gDAAgD;AAChD,eAAe,WAAW,UAA2C;IACnE,IAAI;QACF,MAAM,CAAA,GAAA,uHAAA,CAAA,UAAS,AAAD;QAEd,MAAM,WAAW,CAAC,iIAAkC,EAAE,OAAO;QAC7D,MAAM,YAAY,MAAM,SAAS,IAAI,GAAG,IAAI,CAAC;YAAE,WAAW,CAAC;QAAE;QAE7D,MAAM,uBAAuB,UAAU,GAAG,CAAC,CAAA,WAAY,CAAC;gBACtD,IAAI,SAAS,GAAG,CAAC,QAAQ;gBACzB,cAAc,SAAS,YAAY;gBACnC,YAAY,SAAS,UAAU;gBAC/B,kBAAkB,SAAS,gBAAgB;gBAC3C,gBAAgB,SAAS,cAAc;gBACvC,cAAc,SAAS,YAAY;gBACnC,iBAAiB,SAAS,eAAe;gBACzC,aAAa,SAAS,WAAW;gBACjC,iBAAiB,SAAS,eAAe;gBACzC,MAAM,SAAS,IAAI;gBACnB,cAAc,SAAS,YAAY;gBACnC,WAAW,SAAS,SAAS;gBAC7B,WAAW,SAAS,SAAS;gBAC7B,eAAe,SAAS,aAAa;YACvC,CAAC;QAED,WAAW,OAAO,CAAC,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;YAAE,MAAM;YAAa,MAAM;QAAqB,GAAG,IAAI,CAAC;IACrG,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;IACzC;AACF;AAGO,SAAS;IACd,QAAQ,OAAO,CAAC,CAAA;QACd,IAAI;YACF,WAAW,OAAO,UAAU;QAC9B,EAAE,OAAM;YACN,uBAAuB;YACvB,UAAU,QAAQ,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,OAAO,EAAE;QAClD;IACF;AACF;AAGO,SAAS;IACd,QAAQ,OAAO,CAAC,CAAA;QACd,IAAI;YACF,OAAO,UAAU,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;gBAAE,MAAM;YAAe,GAAG,IAAI,CAAC;QACnF,EAAE,OAAM;YACN,uBAAuB;YACvB,UAAU,QAAQ,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,OAAO,EAAE;QAClD;IACF;AACF;AAGO,SAAS,UAAU,MAAmE;IAC3F,QAAQ,IAAI,CAAC;AACf;AAGO,SAAS,aAAa,QAAgB;IAC3C,UAAU,QAAQ,MAAM,CAAC,CAAA,SAAU,OAAO,EAAE,KAAK;AACnD","debugId":null}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///home/nova/apps/tracking/src/app/api/contracts/stream/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport { addClient, removeClient, sendUpdate } from '@/lib/stream-utils';\n\nexport async function GET(request: NextRequest) {\n  const clientId = Math.random().toString(36).substring(7);\n  \n  const stream = new ReadableStream({\n    start(controller) {\n      // Add client to the list\n      addClient({ id: clientId, controller });\n      \n      // Send initial data\n      sendUpdate(controller);\n      \n      // Keep connection alive with heartbeat\n      const heartbeat = setInterval(() => {\n        try {\n          controller.enqueue(`data: {\"type\":\"heartbeat\"}\\n\\n`);\n        } catch {\n          clearInterval(heartbeat);\n        }\n      }, 30000);\n      \n      // Cleanup on disconnect\n      request.signal.addEventListener('abort', () => {\n        removeClient(clientId);\n        clearInterval(heartbeat);\n        try {\n          controller.close();\n        } catch {\n          // Connection already closed\n        }\n      });\n    }\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Headers': 'Cache-Control'\n    }\n  });\n}"],"names":[],"mappings":";;;AACA;;AAEO,eAAe,IAAI,OAAoB;IAC5C,MAAM,WAAW,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC;IAEtD,MAAM,SAAS,IAAI,eAAe;QAChC,OAAM,UAAU;YACd,yBAAyB;YACzB,CAAA,GAAA,+HAAA,CAAA,YAAS,AAAD,EAAE;gBAAE,IAAI;gBAAU;YAAW;YAErC,oBAAoB;YACpB,CAAA,GAAA,+HAAA,CAAA,aAAU,AAAD,EAAE;YAEX,uCAAuC;YACvC,MAAM,YAAY,YAAY;gBAC5B,IAAI;oBACF,WAAW,OAAO,CAAC,CAAC,8BAA8B,CAAC;gBACrD,EAAE,OAAM;oBACN,cAAc;gBAChB;YACF,GAAG;YAEH,wBAAwB;YACxB,QAAQ,MAAM,CAAC,gBAAgB,CAAC,SAAS;gBACvC,CAAA,GAAA,+HAAA,CAAA,eAAY,AAAD,EAAE;gBACb,cAAc;gBACd,IAAI;oBACF,WAAW,KAAK;gBAClB,EAAE,OAAM;gBACN,4BAA4B;gBAC9B;YACF;QACF;IACF;IAEA,OAAO,IAAI,SAAS,QAAQ;QAC1B,SAAS;YACP,gBAAgB;YAChB,iBAAiB;YACjB,cAAc;YACd,+BAA+B;YAC/B,gCAAgC;QAClC;IACF;AACF","debugId":null}}]
}